# -*- coding: utf-8 -*-
"""CSPC_HW.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1yif0CvLJd2pmAo_lCvbWizwvBNRLsRh1

# Computer Science for Physics and Chemistry Homework Project
## By Murad Mustafayev & Kamal Ahmadov (CS-20)

#### *Setting up*
"""

# importing all the necessary packages
import pickle
import numpy as np
import pandas as pd
from collections.abc import Iterable
from scipy.signal import find_peaks
from matplotlib import pyplot as plt

# opening file and loading its data into a variable
FID = open('/content/data/Homework_L2_2022.dat', 'rb')
data = pickle.load(FID)
FID.close()

x_axis = np.arange(data['Frequency Min'], data['Frequency Max'], data['Frequency Step'])

"""### Exercise

#### *1. Plot the NMR spectrum of ethanoic acid, propanol and propyl-ethanoate*
"""

plt.title('Pure NMR spectrum of ethanoic acid')
plt.xlabel('frequency shift (ppm)')
plt.ylabel('intensity of the signal')
plt.plot(x_axis, data['Pure Spectrums']['Acetic Acid'])

plt.title('Pure NMR spectrum of propanol')
plt.xlabel('frequency shift (ppm)')
plt.ylabel('intensity of the signal')
plt.plot(x_axis, data['Pure Spectrums']['Propanol'])

plt.title('Pure NMR spectrum of propyl-ethanoate')
plt.xlabel('frequency shift (ppm)')
plt.ylabel('intensity of the signal')
plt.plot(x_axis, data['Pure Spectrums']['Propylacetate'])

"""#### *2. Write a function that calculates the position and the intensity of each peak in a NMR spectrum. Apply it to ethanoic acid, propanol and propyl-ethanoate*"""

def peaks(series: Iterable, dist: int = 1000) -> dict:
  """
    This function takes series of data (list or numpy array) as an argument
    and returns a dictionary where the keys represent positions of the peaks (x-values)
    and the values represent the values(intensity) of the peaks (y-values)

    params:
    series: Iterable - series of data to find its peaks
    dist: int (optional, default=1000) - minimal distance between two peaks(filters out the noise)

    returns:
    dict(peak_position : peak_value for each peak)
  """
  indicies = find_peaks(series, distance=dist)[0] # x-positions of peaks
  peak_values = series[indicies] # y-values of peaks (intensity)
  return {
      x_axis[indicies[i]] : peak_values[i] 
      for i in range(len(indicies))
      }

"""**Note about distance value:**
*Default value of the distance parameter for these series was chosen to be 1000 because it seems to be the right one by looking at the graphs. As there is no universal rule to calculate the best distance value (or at least we couldn't deduce one), if this value didn't work as expected, we would've just played with this value to find out the good one.*
"""

# peak intensity signal of the acetic acid spectrum
acetic_acid_peaks = peaks(data['Pure Spectrums']['Acetic Acid'])
acetic_acid_peaks

plt.title('Pure NMR spectrum of ethanoic acid')
plt.xlabel('frequency shift (ppm)')
plt.ylabel('intensity of the signal')
plt.plot(x_axis, data['Pure Spectrums']['Acetic Acid'])
plt.plot(list(acetic_acid_peaks.keys()), list(acetic_acid_peaks.values()), 'x')

# peak intensity signals of the propanol spectrum
propanol_peaks = peaks(data['Pure Spectrums']['Propanol'])
propanol_peaks

plt.title('Pure NMR spectrum of propanol')
plt.xlabel('frequency shift (ppm)')
plt.ylabel('intensity of the signal')
plt.plot(x_axis, data['Pure Spectrums']['Propanol'])
plt.plot(list(propanol_peaks.keys()), list(propanol_peaks.values()), 'x')

# peak intensity signals of the propyl-ethanoate spectrum
propylacetate_peaks = peaks(data['Pure Spectrums']['Propylacetate'])
propylacetate_peaks

plt.title('Pure NMR spectrum of propyl-ethanoate')
plt.xlabel('frequency shift (ppm)')
plt.ylabel('intensity of the signal')
plt.plot(x_axis, data['Pure Spectrums']['Propylacetate'])
plt.plot(list(propylacetate_peaks.keys()), list(propylacetate_peaks.values()), 'x')

"""#### *3. From the initial spectrum (at t=0), estimate the initial concentration of ethanoic acid, propanol and propyl-ethanoate*

First, let's show the data at t=0 and then plot it
"""

data['Measurements'][0]['Data']

plt.plot(x_axis, data['Measurements'][0]['Data'])

"""Now, find the peaks"""

peaks(data['Measurements'][0]['Data'])

"""As it is seen, positions of the peaks correspond to the peaks of acetic acid and propanol. It means that the initial mixture consists of these two compounds.

And now, to calculate the concentration of each compound we'll write a function to reuse it later
"""

def concentration(mixture_peaks: dict, pure_peaks: dict) -> float:
  """
  Calculates the concentration(μmol/L) of a particular substance in a mixture

  params:
  mixture_peaks: dict - NMR spectrum peaks of the mixture
  pure_peaks: dict - NMR spectrum peaks of the pure substance(C = 1μmol/L)

  returns:
  concentration of the given substance in this mixture (μmol/L)
  """
  # Searching for the minimal value of concentration
  # among the ones calculated from each peak.
  # Why to do so, will be explained in the section below.
  concentration = np.inf
  for x in pure_peaks.keys():
    if x not in mixture_peaks.keys():
      return 0
    if mixture_peaks[x] / pure_peaks[x] < concentration:
      concentration = mixture_peaks[x] / pure_peaks[x]
  return concentration

"""Concentration can be found with any of the peaks and result should be the same (with correction to the noise). However there is a chance that the peaks of different compounds coincide. In this case the peak will be higher because it represents 'the sum' of two different conpounds, which is not what we need. This is why we returned the minimal of the concentration values in the 'concentration' function. Actually, this values can possibly be a little bit smaller than it is in reality due to the noise, but for now there is hardly any way to find out how much of noise there is in the data and how to compensate it. Hopefully, and most probably, the measurements are precise enough for noise to be neglectible."""

# Initial concentration of ethanoic acid
concentration(peaks(data['Measurements'][0]['Data'], dist=50), acetic_acid_peaks)

# Initial concentration of propanol
concentration(peaks(data['Measurements'][0]['Data']), propanol_peaks)

# Initial concentration of propyl-ethanoate
concentration(peaks(data['Measurements'][0]['Data'], dist=50), propylacetate_peaks)

"""Note that we had to decrease *dist* parameter. This is because one of the peaks of propylacetate is very close to the peak of acetic acid. So, if *dist* parameter is too large, these peaks overlap and are shown as just one peak instead of two. For this step it makes no difference, because initial concentration of propyl-ethanoate is 0, but it will be important later on.

#### *4. Analyze the NMR spectrums to plot the evolution of the concentration of ethanoic acid, propanol and propyl-ethanoate during the reaction.*
"""

def concentration_over_time(measurements: list, compound_peaks: dict, dist: int=50) -> dict:
  """
  Returns a dictionary representing evolution of concentration of the compound over the time

  params:
  measurements: list -
  compound_peaks: dict - NMR spectrum peaks of the pure substance(C = 1μmol/L)
  dist: int (optional, default=50) - minimal distance between two peaks(filters out the noise)

  returns:
  dict(time : concentration)
  """
  evolution = {}
  for measurement in measurements:
    mixture_peaks = peaks(measurement['Data'], dist=dist)
    evolution[measurement['Time']] = concentration(mixture_peaks, compound_peaks)
  return evolution

# getting the evolution of each compound
acetic_acid_evolution = concentration_over_time(data['Measurements'], acetic_acid_peaks)
propanol_evolution = concentration_over_time(data['Measurements'], propanol_peaks)
propylacetate_evolution = concentration_over_time(data['Measurements'], propylacetate_peaks)

# plot the data
plt.suptitle(data['title'], fontsize=14)
plt.title('Evolution of concentration of each compound', fontsize=10, fontweight='bold')
plt.xlabel('time (s)')
plt.ylabel('concentration (µmol/L)')
plt.plot(list(acetic_acid_evolution.keys()), list(acetic_acid_evolution.values()), label='acetic acid')
plt.plot(list(propanol_evolution.keys()), list(propanol_evolution.values()), label='propanol')
plt.plot(list(propylacetate_evolution.keys()), list(propylacetate_evolution.values()), label='propylacetate')
plt.legend()

"""#### *5. From these data, estimate the value of the reaction constant k.*

To calculate the value of *k* we have these equations:

𝑣 = 𝑘 ∙ [𝐸𝐴] ∙ [𝑃𝑟𝑜];

𝑑[𝐸𝐴]/𝑑𝑡 = −𝑣 ;

𝑑[𝑃𝑟𝑜]/𝑑𝑡 = −𝑣;

𝑑[𝑃𝐸]/𝑑𝑡 = 𝑣;

And to solve them we need a derivative function, which can be expressed mathematically as:

*dx/dt = (x(t+Δt) - x(t)) / Δt*

*Where Δt approaches 0.*

In reality, though we are quite limited in terms of how close can Δt be to 0. In our case Δt will be the interval between two consequent measurements, which is 0.25 seconds.
"""

def derivative(series: dict) -> dict:
  derivative_series = {}
  for i in range(len(series) - 1):
    t = list(series.keys())[i]
    delta_t = list(series.keys())[i+1] - t # could use just 0.25, but let's make it reusable
    derivative_series[t] = (series[t + delta_t] - series[t]) / delta_t
  return derivative_series

"""Now we can calculate the 𝑣 value.
There are three equations and therefore three ways to compute it all giving a slightly different result because of an error in our values. To minimize the error in the final 𝑣 value we'll calculate the average of three very close values obtained by three equations.
"""

def v(t:float) -> float:
  v1 = - derivative(acetic_acid_evolution)[t]
  v2 = - derivative(propanol_evolution)[t]
  v3 = derivative(propylacetate_evolution)[t]
  return (v1 + v2 + v3) / 3

"""Finally, we can compute the *k* value.
We can compute it at any point and get very similar values, but again, we'll find the average to minimize the error.
"""

def compute_k() -> float:
  k_vals = []
  for t in list(acetic_acid_evolution.keys())[:-1]:
    k = v(t) / (acetic_acid_evolution[t] * propanol_evolution[t])
    k_vals.append(k)
  return sum(k_vals) / len(k_vals)

k = compute_k()
k

